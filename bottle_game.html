<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Poti Game</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
  <style>
    /* Make the app truly full-screen and use safe-area insets */
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      background: #222;
      overflow: hidden;
      touch-action: none;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }

    #phaser-game {
      position: fixed;
      inset: 0; /* top:0; left:0; right:0; bottom:0 */
      width: 100vw;
      height: 100vh;
      padding-top: env(safe-area-inset-top);
      padding-bottom: env(safe-area-inset-bottom);
      padding-left: env(safe-area-inset-left);
      padding-right: env(safe-area-inset-right);
      box-sizing: border-box;
      display: block;
      -webkit-transform: translateZ(0);
    }

    canvas {
      display: block;
      width: 100% !important;
      height: 100% !important;
    }
  </style>
</head>
<body>
  <div id="phaser-game"></div>

<script>
class GameScene extends Phaser.Scene {
  constructor() {
    super('GameScene');
    this.totalBottles = 6;
    this.gameActive = false; // Prevents movement before start
  }

  preload() {
    this.load.image('background', 'licensed-image.jpg');
  }

  create() {
    // Store game dimensions (use base game size, not scaled)
    this.gameWidth = 1200;
    this.gameHeight = 700;
    this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    this.isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
    this.isAndroid = /Android/i.test(navigator.userAgent);
    
    // Adjust scale for different devices
    if (this.isIOS) {
      // iPhone - scale down slightly (they have high DPI screens)
      this.scale.setZoom(0.85);
    } else if (this.isAndroid) {
      // Android - scale up slightly (often lower DPI)
      this.scale.setZoom(1.15);
    }
    
    // Get actual display size for positioning
    this.displayWidth = this.scale.displaySize.width;
    this.displayHeight = this.scale.displaySize.height;

    // 1. BACKGROUND & scale factors
    // Use the actual display size so objects map correctly to portrait/landscape
    const dispW = this.scale.displaySize.width;
    const dispH = this.scale.displaySize.height;
    const sx = dispW / this.gameWidth;
    const sy = dispH / this.gameHeight;

    const bg = this.add.image(0, 0, 'background').setOrigin(0, 0);
    bg.setDisplaySize(dispW, dispH);

    // 2. GENERATE TEXTURES
    this.makeBetterPlayer(); 
    this.makeBottleTextures();
    this.makeTrashCanTexture();
    this.makePlatformTextures();

    // 3. PHYSICS & FLOOR
    this.platforms = this.physics.add.staticGroup();
    const groundYBase = this.gameHeight - 105; // base coordinate
    const groundY = groundYBase * sy;
    const groundBody = this.add.rectangle((this.gameWidth/2) * sx, groundY, this.gameWidth * sx, 20 * sy, 0x000000, 0);
    this.physics.add.existing(groundBody, true);
    this.platforms.add(groundBody);

    // 4. PLATFORMS - scaled positions
    const levelLayoutBase = [
      {x: 220, y: 440, w: 150, c: 'plat_red'},
      {x: 450, y: 360, w: 150, c: 'plat_blue'},
      {x: 680, y: 400, w: 130, c: 'plat_yellow'},
      {x: 580, y: 230, w: 150, c: 'plat_green'},
      {x: 880, y: 300, w: 150, c: 'plat_red'},
      {x: 1080, y: 340, w: 130, c: 'plat_blue'}
    ];

    levelLayoutBase.forEach(pb => {
      const px = pb.x * sx;
      const py = pb.y * sy;
      const pw = pb.w * sx;
      const plat = this.platforms.create(px, py, pb.c);
      plat.setDisplaySize(pw, 35 * sy);
      plat.refreshBody();
    });

    // 5. TRASH CAN - scaled
    const trashCanX = (this.gameWidth - 70) * sx;
    const trashCanY = (groundYBase - 40) * sy;
    this.trashCan = this.physics.add.staticSprite(trashCanX, trashCanY, 'trashcan');
    this.trashCan.setDisplaySize(60 * sx, 80 * sy);
    this.trashCan.setDepth(5);

    // 6. PLAYER - scaled start position
    const playerX = 100 * sx;
    const playerY = (groundYBase - 95) * sy;
    this.player = this.physics.add.sprite(playerX, playerY, 'player_idle');
    this.player.setDisplaySize(50 * sx, 90 * sy);
    this.player.setCollideWorldBounds(true);
    this.player.setDepth(10);
    this.player.setBounce(0.1);

    // Walking animation state
    this.walkFrame = 0;      // 0 = idle, 1 & 2 = walking frames
    this.walkAnimTime = 0;   // time accumulator for walk animation

    // 7. BOTTLES - scaled
    this.bottles = this.physics.add.group();
    levelLayoutBase.forEach(pb => {
      const bx = pb.x * sx;
      const by = (pb.y - 60) * sy;
      const b = this.bottles.create(bx, by, 'glass');
      b.body.allowGravity = false;
      b.setDisplaySize(30 * sx, 50 * sy);
    });

    // COLLIDERS
    this.physics.add.collider(this.player, this.platforms);
    this.physics.add.overlap(this.player, this.bottles, (p, b) => {
      b.disableBody(true, true);
      this.collected++;
      this.updateScore();
    }, null, this);

    // UI & INPUT
    this.cursors = this.input.keyboard.createCursorKeys();
    this.jumpKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
    this.collected = 0;
    this.deposited = 0;
    // Score text - responsive font size
    const fontSize = this.isMobile ? 18 : 26;
    this.scoreText = this.add.text(20 * sx, 20 * sy, 'ჩანთაში: 0 | შეგროვებული: 0', {
      fontSize: fontSize + 'px', fill: '#fff', stroke: '#000', strokeThickness: 5
    }).setScrollFactor(0);

    // MOBILE TOUCH CONTROLS
    // Ensure multiple touch pointers are available (allow simultaneous presses)
    if (this.input && this.input.addPointer) {
      this.input.addPointer(2); // add two extra pointers (total 3)
    }
    this.createTouchControls();

    // INITIAL POPUP
    this.showPopup("LEVEL 1", "დონე : მარტივი\nშეაგროვე 6 ბოთლი და\n მოათავსე ნაგვის ურნაში.", "თამაშის დაწყება", () => {
      this.gameActive = true;
    });
  }

  update(time, delta) {
    if (!this.gameActive) {
        this.player.setVelocityX(0);
        return;
    }

    // Check both keyboard and touch controls
    const leftPressed = this.cursors.left.isDown || this.leftButtonPressed;
    const rightPressed = this.cursors.right.isDown || this.rightButtonPressed;
    const jumpPressed = this.cursors.up.isDown || this.jumpKey.isDown || this.jumpButtonPressed;

    // Handle movement
    if (leftPressed) { 
      this.player.setVelocityX(-300); 
    } else if (rightPressed) { 
      this.player.setVelocityX(300); 
    } else { 
      this.player.setVelocityX(0); 
    }

    // Handle jump - only when on ground or very close to it
    const canJump = this.player.body.touching.down || this.player.body.blocked.down;
    if (jumpPressed && canJump) {
      this.player.setVelocityY(-720);
    }

    // Deposit Logic
    const dist = Phaser.Math.Distance.Between(this.player.x, this.player.y, this.trashCan.x, this.trashCan.y);
    if (dist < 80 && this.collected > 0) {
      this.deposited += this.collected;
      this.collected = 0;
      this.updateScore();
      this.trashCan.setTint(0x00ff00);
      this.time.delayedCall(200, () => this.trashCan.clearTint());

      // WIN CHECK
      if (this.deposited >= this.totalBottles) {
          this.gameActive = false;
          this.time.delayedCall(500, () => {
              this.showPopup("ყოჩაღ!", "ბუნება გასუფთავდა", "შემდეგი დონე", () => {
                  this.scene.restart(); // Future: Load Level 2 here
              });
          });
      }
    }

    // --- WALK ANIMATION ---
    const movingHorizontally = Math.abs(this.player.body.velocity.x) > 5;
    const onGround = this.player.body.touching.down || this.player.body.blocked.down;

    if (movingHorizontally && onGround) {
      // Accumulate time for animation
      this.walkAnimTime += delta;
      if (this.walkAnimTime > 120) { // switch frame every ~120ms
        // Toggle between walking frames 1 and 2
        this.walkFrame = this.walkFrame === 1 ? 2 : 1;
        const texKey = this.walkFrame === 1 ? 'player_walk1' : 'player_walk2';
        this.player.setTexture(texKey);
        this.walkAnimTime = 0;
      }
    } else {
      // Not moving or in air → idle pose
      if (this.walkFrame !== 0) {
        this.player.setTexture('player_idle');
        this.walkFrame = 0;
      }
      this.walkAnimTime = 0;
    }
  }

  updateScore() {
    this.scoreText.setText(`ჩანთაში: ${this.collected} | შეგროვებული: ${this.deposited}`);
  }

  createTouchControls() {
    // Initialize button states
    this.leftButtonPressed = false;
    this.rightButtonPressed = false;
    this.jumpButtonPressed = false;
    this.jumpButtonJustPressed = false;
    this._touchPointerMap = {}; // maps pointer.id -> action ('left'|'right'|'jump')

    // Button sizes - larger on mobile for easier tapping
    const btnRadius = this.isMobile ? 50 : 40;
    const jumpBtnRadius = this.isMobile ? 60 : 50;
    const btnFontSize = this.isMobile ? 40 : 32;
    const jumpFontSize = this.isMobile ? 44 : 36;

    // Compute positions based on actual display size so portrait/landscape work
    const displayW = this.scale.displaySize.width;
    const displayH = this.scale.displaySize.height;

    const bottomOffset = Math.max(60, Math.round(displayH * 0.08));
    const btnY = displayH - bottomOffset;

    // Horizontal offsets from edges
    const edgePadding = Math.max(40, Math.round(displayW * 0.06));
    const leftBtnX = edgePadding + btnRadius;
    const rightBtnX = leftBtnX + (btnRadius * 2) + 16;
    const jumpBtnX = displayW - edgePadding - jumpBtnRadius;

    // Button style
    const buttonStyle = {
      fontSize: btnFontSize + 'px',
      fill: '#ffffff',
      stroke: '#000000',
      strokeThickness: 4
    };

    // Left button
    const leftBtn = this.add.circle(leftBtnX, btnY, btnRadius, 0x43a047, 0.8)
      .setInteractive({ useHandCursor: true })
      .setDepth(50)
      .setScrollFactor(0);
    const leftText = this.add.text(leftBtnX, btnY, '←', buttonStyle)
      .setOrigin(0.5)
      .setDepth(51)
      .setScrollFactor(0);

    // Add a larger invisible hit area behind the visible circle for easier tapping
    const leftHit = this.add.circle(leftBtnX, btnY, btnRadius + 18, 0x000000, 0.001).setInteractive({ useHandCursor: true }).setDepth(49).setScrollFactor(0);
    leftHit.on('pointerdown', (pointer) => { this._touchPointerMap[pointer.id] = 'left'; this.leftButtonPressed = true; });
    leftHit.on('pointerup', (pointer) => { if (this._touchPointerMap[pointer.id] === 'left') { this.leftButtonPressed = false; delete this._touchPointerMap[pointer.id]; } });
    leftHit.on('pointerupoutside', (pointer) => { if (this._touchPointerMap[pointer.id] === 'left') { this.leftButtonPressed = false; delete this._touchPointerMap[pointer.id]; } });
    leftBtn.setPosition(leftBtnX, btnY);
    leftText.setPosition(leftBtnX, btnY);

    // Right button
    const rightBtn = this.add.circle(rightBtnX, btnY, btnRadius, 0x43a047, 0.8)
      .setInteractive({ useHandCursor: true })
      .setDepth(50)
      .setScrollFactor(0);
    const rightText = this.add.text(rightBtnX, btnY, '→', buttonStyle)
      .setOrigin(0.5)
      .setDepth(51)
      .setScrollFactor(0);

    const rightHit = this.add.circle(rightBtnX, btnY, btnRadius + 18, 0x000000, 0.001).setInteractive({ useHandCursor: true }).setDepth(49).setScrollFactor(0);
    rightHit.on('pointerdown', (pointer) => { this._touchPointerMap[pointer.id] = 'right'; this.rightButtonPressed = true; });
    rightHit.on('pointerup', (pointer) => { if (this._touchPointerMap[pointer.id] === 'right') { this.rightButtonPressed = false; delete this._touchPointerMap[pointer.id]; } });
    rightHit.on('pointerupoutside', (pointer) => { if (this._touchPointerMap[pointer.id] === 'right') { this.rightButtonPressed = false; delete this._touchPointerMap[pointer.id]; } });
    rightBtn.setPosition(rightBtnX, btnY);
    rightText.setPosition(rightBtnX, btnY);

    // Jump button (on the right side)
    const jumpBtn = this.add.circle(jumpBtnX, btnY, jumpBtnRadius, 0xff6b35, 0.8)
      .setInteractive({ useHandCursor: true })
      .setDepth(50)
      .setScrollFactor(0);
    const jumpText = this.add.text(jumpBtnX, btnY, '↑', {
      fontSize: jumpFontSize + 'px',
      fill: '#ffffff',
      stroke: '#000000',
      strokeThickness: 4
    })
      .setOrigin(0.5)
      .setDepth(51)
      .setScrollFactor(0);

    const jumpHit = this.add.circle(jumpBtnX, btnY, jumpBtnRadius + 20, 0x000000, 0.001).setInteractive({ useHandCursor: true }).setDepth(49).setScrollFactor(0);
    jumpHit.on('pointerdown', (pointer) => { 
      this._touchPointerMap[pointer.id] = 'jump';
      this.jumpButtonPressed = true;
      this.jumpButtonJustPressed = true;
      if (this.gameActive && (this.player.body.touching.down || this.player.body.blocked.down)) {
        this.player.setVelocityY(-720);
      }
    });
    jumpHit.on('pointerup', (pointer) => { 
      if (this._touchPointerMap[pointer.id] === 'jump') { this.jumpButtonPressed = false; this.jumpButtonJustPressed = false; delete this._touchPointerMap[pointer.id]; }
    });
    jumpHit.on('pointerupoutside', (pointer) => { 
      if (this._touchPointerMap[pointer.id] === 'jump') { this.jumpButtonPressed = false; this.jumpButtonJustPressed = false; delete this._touchPointerMap[pointer.id]; }
    });
    jumpBtn.setPosition(jumpBtnX, btnY);
    jumpText.setPosition(jumpBtnX, btnY);

    // Store references
    this.touchControls = {
      leftBtn, leftText, rightBtn, rightText, jumpBtn, jumpText,
      leftHit, rightHit, jumpHit
    };

    // Reposition on resize/orientation change
    const reposition = () => {
      const w = this.scale.displaySize.width;
      const h = this.scale.displaySize.height;
      const bottom = h - Math.max(60, Math.round(h * 0.08));
      const edge = Math.max(40, Math.round(w * 0.06));
      const lx = edge + btnRadius;
      const rx = lx + (btnRadius * 2) + 16;
      const jx = w - edge - jumpBtnRadius;

      leftBtn.setPosition(lx, bottom); leftText.setPosition(lx, bottom); this.touchControls.leftHit.setPosition(lx, bottom);
      rightBtn.setPosition(rx, bottom); rightText.setPosition(rx, bottom); this.touchControls.rightHit.setPosition(rx, bottom);
      jumpBtn.setPosition(jx, bottom); jumpText.setPosition(jx, bottom); this.touchControls.jumpHit.setPosition(jx, bottom);
    };

    this.scale.on('resize', reposition);
    window.addEventListener('resize', reposition);
    // Initial position (ensure correct placement)
    reposition();
  }

  // --- POPUP UI FUNCTION ---
  showPopup(titleText, descText, btnLabel, callback) {
    const isMobile = this.isMobile;
    const dispW = this.scale.displaySize.width;
    const dispH = this.scale.displaySize.height;
    const centerX = Math.round(dispW / 2);
    const centerY = Math.round(dispH / 2);

    // Dark Overlay - positioned at screen center
    const overlay = this.add.rectangle(centerX, centerY, dispW, dispH, 0x000000, 0.7).setDepth(99);

    // Container for popup elements
    const container = this.add.container(centerX, centerY).setDepth(100);

    // Responsive popup sizes (use display size to compute)
    const boxWidth = isMobile ? Math.round(dispW * 0.85) : 450;
    const boxHeight = isMobile ? Math.round(dispH * 0.5) : 300;
    const titleFontSize = isMobile ? 32 : 42;
    const descFontSize = isMobile ? 18 : 22;
    const btnFontSize = isMobile ? 20 : 24;
    const btnWidth = isMobile ? Math.round(boxWidth * 0.7) : 220;
    const btnHeight = isMobile ? 50 : 60;

    // Background Box
    const box = this.add.rectangle(0, 0, boxWidth, boxHeight, 0xffffff, 1);
    box.setStrokeStyle(6, 0x43a047);

    // Title
    const title = this.add.text(0, isMobile ? -boxHeight * 0.3 : -100, titleText, {
      fontSize: titleFontSize + 'px', fill: '#1b5e20', fontWeight: 'bold'
    }).setOrigin(0.5);

    // Description
    const desc = this.add.text(0, isMobile ? -20 : -20, descText, {
      fontSize: descFontSize + 'px', fill: '#333', align: 'center',
      wordWrap: { width: boxWidth - 40 }
    }).setOrigin(0.5);

    // Button
    const btnBg = this.add.rectangle(0, isMobile ? boxHeight * 0.25 : 80, btnWidth, btnHeight, 0x43a047).setInteractive({ useHandCursor: true });
    const btnText = this.add.text(0, isMobile ? boxHeight * 0.25 : 80, btnLabel, { 
      fontSize: btnFontSize + 'px', fill: '#fff' 
    }).setOrigin(0.5);

    btnBg.on('pointerdown', () => {
        container.destroy();
        overlay.destroy();
        callback();
    });

    container.add([box, title, desc, btnBg, btnText]);
    
    // Store references for cleanup
    this.popupOverlay = overlay;
    this.popupContainer = container;
  }

  // --- CHARACTER DESIGN & WALK ANIMATION FRAMES ---
  makeBetterPlayer() {
    // Create three poses: idle, walk1, walk2
    this.createPlayerPose('player_idle', 0, 0, 0, 0);
    // Left leg forward, right leg back, arms swing
    this.createPlayerPose('player_walk1', -6, 4, -4, 4);
    // Right leg forward, left leg back, arms swing opposite
    this.createPlayerPose('player_walk2', 4, -6, 4, -4);
  }

  createPlayerPose(key, leftLegDY, rightLegDY, leftArmDY, rightArmDY) {
    const g = this.make.graphics({ add: false });
    
    // Legs
    g.fillStyle(0x0d47a1, 1);
    g.fillRect(15, 65 + leftLegDY, 8, 18);
    g.fillStyle(0x1565c0, 1); 
    g.fillRect(15, 65 + leftLegDY, 3, 18);
    
    g.fillStyle(0x0d47a1, 1);
    g.fillRect(27, 65 + rightLegDY, 8, 18);
    g.fillStyle(0x1565c0, 1);
    g.fillRect(27, 65 + rightLegDY, 3, 18);
    
    g.fillStyle(0x424242, 1);
    g.fillEllipse(19, 83 + leftLegDY, 10, 4); 
    g.fillEllipse(31, 83 + rightLegDY, 10, 4); 

    // Body
    g.fillStyle(0x1976d2, 1);
    g.fillRoundedRect(12, 32, 26, 32, 5);
    g.fillStyle(0x2196f3, 1);
    g.fillRoundedRect(12, 32, 8, 32, 5);
    
    // Arms
    g.fillStyle(0x1976d2, 1);
    g.fillRoundedRect(5, 35 + leftArmDY, 6, 22, 3);
    g.fillRoundedRect(39, 35 + rightArmDY, 6, 22, 3);
    
    g.fillStyle(0xffccbc, 1);
    g.fillCircle(8, 57 + leftArmDY, 4); 
    g.fillCircle(42, 57 + rightArmDY, 4); 

    // Head
    g.fillStyle(0xffccbc, 1);
    g.fillCircle(25, 16, 13);
    
    // Hair
    g.fillStyle(0x3e2723, 1);
    g.fillEllipse(25, 8, 20, 12);

    // Face
    g.fillStyle(0xffffff, 1);
    g.fillCircle(21, 15, 3.5);
    g.fillCircle(29, 15, 3.5);
    g.fillStyle(0x000000, 1);
    g.fillCircle(21, 15, 2);
    g.fillCircle(29, 15, 2);
    
    g.lineStyle(2, 0x000000);
    g.beginPath();
    g.arc(25, 21, 7, 0, Math.PI);
    g.strokePath();

    g.generateTexture(key, 50, 90);
    g.destroy();
  }

  makePlatformTextures() {
    const colors = { plat_red: 0xff4747, plat_blue: 0x47a3ff, plat_green: 0x47ff78, plat_yellow: 0xffd947 };
    Object.keys(colors).forEach(key => {
      const g = this.make.graphics({ add: false });
      g.fillStyle(colors[key]); g.fillRoundedRect(0, 0, 100, 30, 8);
      g.lineStyle(3, 0x000); g.strokeRoundedRect(0, 0, 100, 30, 8);
      g.generateTexture(key, 100, 30);
      g.destroy();
    });
  }

  makeBottleTextures() {
    const g = this.make.graphics({ add: false });
    g.fillStyle(0xb3e5fc, 0.8); g.fillRoundedRect(4, 10, 22, 40, 6);
    g.fillRoundedRect(10, 0, 10, 10, 3);
    g.fillStyle(0xffffff, 0.4); g.fillRect(8, 14, 4, 28);
    g.fillStyle(0x8d6e63, 1); g.fillRect(10, -4, 10, 4);
    g.generateTexture('glass', 30, 50);
    g.destroy();
  }

  makeTrashCanTexture() {
    const g = this.make.graphics({ add: false });
    
    // Main body with rounded corners
    g.fillStyle(0x424242, 1);
    g.fillRoundedRect(8, 20, 44, 55, 4);
    
    // Body shading/highlight
    g.fillStyle(0x616161, 1);
    g.fillRoundedRect(8, 20, 12, 55, 4);
    
    // Top rim/opening
    g.fillStyle(0x555555, 1);
    g.fillRoundedRect(5, 18, 50, 8, 3);
    
    // Lid/top cover
    g.fillStyle(0x757575, 1);
    g.fillRoundedRect(2, 12, 56, 10, 4);
    g.fillStyle(0x616161, 1);
    g.fillRoundedRect(2, 12, 56, 4, 4);
    
    // Handle on lid
    g.fillStyle(0x424242, 1);
    g.fillRoundedRect(22, 8, 12, 6, 2);
    g.fillStyle(0x333333, 1);
    g.fillRoundedRect(24, 6, 8, 4, 1);
    
    // Decorative lines/bands on body
    g.lineStyle(2, 0x616161);
    g.beginPath();
    g.moveTo(12, 40);
    g.lineTo(48, 40);
    g.strokePath();
    g.beginPath();
    g.moveTo(12, 55);
    g.lineTo(48, 55);
    g.strokePath();
    g.beginPath();
    g.moveTo(12, 50);
    g.lineTo(48, 50);
    g.strokePath();
    
    // Recycling symbol (simplified)
    g.lineStyle(2, 0x43a047);
    g.beginPath();
    g.moveTo(25, 30);
    g.lineTo(30, 35);
    g.lineTo(25, 40);
    g.strokePath();
    g.beginPath();
    g.moveTo(30, 30);
    g.lineTo(25, 35);
    g.lineTo(30, 40);
    g.strokePath();
    
    // Bottom base/shadow
    g.fillStyle(0x212121, 1);
    g.fillEllipse(30, 75, 50, 8);
    
    g.generateTexture('trashcan', 60, 80);
    g.destroy();
  }
}

// Base game dimensions
const baseWidth = 1200;
const baseHeight = 700;

const config = {
  type: Phaser.AUTO,
  width: baseWidth,
  height: baseHeight,
  physics: { default: 'arcade', arcade: { gravity: { y: 1300 }, debug: false } },
  resolution: window.devicePixelRatio || 1,
  scene: GameScene,
  scale: {
    mode: Phaser.Scale.FIT,
    autoCenter: Phaser.Scale.CENTER_BOTH,
    width: baseWidth,
    height: baseHeight,
    parent: 'phaser-game'
  }
};

new Phaser.Game(config);
</script>

</body>
</html>
